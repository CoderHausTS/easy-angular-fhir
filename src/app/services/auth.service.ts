import { Injectable } from '@angular/core';
import { HttpClient, HttpParams, HttpHeaders } from '@angular/common/http';
import { ConformanceParserService } from './conformance-parser.service';
import { AppConfigService } from './app-config.service';

@Injectable({
  providedIn: 'root',
})
export class AuthService {
  private authorizationURL;
  private authorizeCode;
  private token;
  private patient;

  // private codeChallenge;
  // private codeVerifier;

  constructor(
    private http: HttpClient,
    private conformanceService: ConformanceParserService
  ) {}

  // we want to hide the client id etc from other services
  // this could be with something like AWS Secrets Manager, or a private API server that serves it

  // we need a code verifier, then create a code_challenge from that. Code challenge is sent to API.
  //   code_challenge: This optional parameter is generated by your app and used for PKCE.
  //This is the S256 hashed version of the code_verifier parameter, which will be used in the token request.
  // code_challenge_method: This optional parameter indicates the method used for the code_challenge
  //parameter and is required if using that parameter. Currently, only the S256 method is supported.

  // the API server stores teh code_challenge.
  // This should NOT be done here, you'll lose the verifier when you refresh
  // folks should look at https://github.com/aaronpk/pkce-vanilla-js
  // generateCodeVerifier() {
  //   // pkce code verifier
  //   const array = new Uint32Array(32);
  //   const code = btoa(crypto.getRandomValues(array).toString());
  //   return code.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
  // }

  // generateCodeChallenge(codeVerifier: string) {
  //   // return crypto.createHash('sha256').update(buffer).digest();
  //   const encoder = new TextEncoder();
  //   const data = encoder.encode(codeVerifier);
  //   let hashedData;
  //   window.crypto.subtle
  //     .digest('SHA-256', data)
  //     .then((resultData) => (hashedData = resultData));
  //   return btoa(hashedData)
  //     .replace(/\+/g, '-')
  //     .replace(/\//g, '_')
  //     .replace(/=+$/, '');
  // }

  fetchAuthorizationCode() {
    const responseType = 'code';
    const clientId = AppConfigService.settings.fhir.clientId;
    const redirectUri = AppConfigService.settings.fhir.redirectUrl;

    this.authorizationURL = this.conformanceService.getAuthorizationURL();

    // for pkce. You will NOT want to create the verifier here
    // you'll lose it on refresh. Do this in a service
    // this.codeVerifier = this.generateCodeVerifier();
    // console.log('code verifier ', this.codeVerifier);
    // this.codeChallenge = this.generateCodeChallenge(this.codeVerifier);
    // console.log('code challenge ', this.codeChallenge);

    const params = new HttpParams({
      fromObject: {
        response_type: responseType,
        client_id: clientId,
        redirect_uri: redirectUri,
        scope: '',
        state: '',
        // code_challenge: this.codeChallenge,
        // code_challenge_method: 'S256',
      },
    });

    window.location.href = this.authorizationURL + '?' + params.toString();
  }

  setAuthorizationCode(code: string) {
    this.authorizeCode = code;
  }

  // we then get back the auth code
  // code: This parameter contains the authorization code generated by Epic.
  // localhost:8000?code=l7LJWdznuuA9oZw+JCNsG70ewv0AzxOD2MI1yGwg

  // exchange the code for a token
  // we send the code, and the code verifier back to the token endpoint
  // the API then validates both teh code and verifier
  // HTTP POST to the token service
  // needs these params
  // grant_type: In Epic's OAuth 2.0 implementation, this parameter always contains the value authorization_code.
  // code: This parameter contains the authorization code sent from Epic's authorization server to your application
  // as a query parameter on the redirect URI as described above.
  // redirect_uri: This parameter must contain the same redirect URI that you provided in the initial access request.
  // client_id: This parameter must contain the applicationâ€™s client ID issued by Epic that you provided in the intial request.
  // POST https://open-ic.epic.com/argonaut/oauth2/token HTTP/1.1
  // Content-Type: application/x-www-form-urlencoded
  // grant_type=authorization_code&code=QY4IDRFBZOPtYenTOADbBrBUTF
  // &redirect_uri=http://localhost:8000&client_id=324C2091A1CB4A319FBB3FC805863F0A

  //   grant_type: For the EHR launch flow, this should contain the value "authorization_code".
  // code: This parameter contains the authorization code sent from Epic's authorization server
  //           to your application as a querystring parameter on the redirect URI as described above.
  // redirect_uri: This parameter must contain the same redirect URI that you provided in the initial access request.
  // client_id: This parameter must contain the application's client ID issued by Epic that you
  //      provided in the initial request.
  // code_verifier: This optional parameter is used to verify against your code_challenge parameter
  //           when using PKCE. This parameter is passed as free text and must match the code_challenge parameter used in your authorization request once it is hashed on the server using the code_challenge_method. This parameter is available starting in the August 2019 version of Epic.
  fetchAuthorizationToken() {
    let tokenURL = this.conformanceService.getTokenURL();
    let grantType = 'authorization_code';
    let redirectURI = AppConfigService.settings.fhir.redirectUrl;
    let clientID = AppConfigService.settings.fhir.clientId;

    console.log('auth code is ', this.authorizeCode);
    const httpOptions = {
      headers: new HttpHeaders({
        'Content-Type': 'application/x-www-form-urlencoded',
      }),
    };

    const body = new HttpParams({
      fromObject: {
        grant_type: grantType,
        code: this.authorizeCode,
        redirect_uri: redirectURI,
        client_id: clientID,
        // code_verifier: this.codeVerifier
      },
    });

    this.http.post(tokenURL, body.toString(), httpOptions).subscribe((data) => {
      this.parseTokenResponse(data);
      console.log('This is the auth token response body: ', data);
    });
  }

  // access_token: "data"
  // token_type: "bearer"
  // expires_in: 3600
  // scope: "Medication.read Medication.search MEDICATIONSTATEMENT.READ MEDICATIONSTATEMENT.SEARCH "
  // patient: "the patient data"

  parseTokenResponse(tokenData) {
    this.patient = tokenData.patient;
    this.token = tokenData.access_token;
  }

  // we then get back the token
  // it contains a json object with the following
  // access_token: This parameter contains the access token issued by Epic to your application and is used in future requests.
  // token_type: In Epic's OAuth 2.0 implementation, this parameter always includes the value bearer.
  // expires_in: This parameter contains the number of seconds for which the access token is valid.
  // scope: This parameter describes the access your application is authorized for.
  // {
  //       "access_token": "Ft2FxQoCRMYtyvtbBE29yEbaOjKKdLBVWeT\/cGGOwbPTPtJz0KPLPSsWkjcHMG",
  //       "token_type": "bearer",
  //       "expires_in": 3240,
  //       "scope": "* ",
  //       "patient": "Tbt3KuCY0B5PSrJvCu2j-PlK.aiHsu2xUjUM8bWpetXoB"
  //     }

  // With this, we can get our data!!!!
  // Queries must contain an Authorization header that includes the access token presented as a bearer token.
  // https://open-ic.epic.com/argonaut/api/FHIR/Argonaut/Patient/Tbt3KuCY0B5PSrJvCu2j-PlK.aiHsu2xUjUM8bWpetXoB
  // Authorization: Bearer Ft2FxQoCRMYtyvtbBKdLBVWeT/cGGOwbPTPtJz0KPLPSsWkjcHMG
  getToken() {
    return this.token;
  }

  getPatient() {
    return this.patient;
  }
}

// https://open.epic.com/Tutorial/PatientAuthentication
// https://open.epic.com/Tutorial/OAuth
// https://open.epic.com/MyApps/Endpoints

// If you are using a client secret:
// You should no longer pass the client_id parameter in the POST body. Instead,
// you should pass an Authorization header with value of base64([client_id]:[client_secret])
// where the [client_id] and [client_secret] are both URL encoded.

// An Authorization header using HTTP Basic Authentication is required, where the username
// is the URL encoded client_id and the password is the URL encoded client_secret. Using
// the following parameters and values:

// client_id: d45049c3-3441-40ef-ab4d-b9cd86a17225

// URL encoded client_id: d45049c3-3441-40ef-ab4d-b9cd86a17225

// client_secret: this-is-the-secret-2/7

// URL encoded client_secret: this-is-the-secret-2%2F7

// Authorization: Basic base64Encode{d45049c3-3441-40ef-ab4d-b9cd86a17225:this-is-the-secret-2%2F7}
